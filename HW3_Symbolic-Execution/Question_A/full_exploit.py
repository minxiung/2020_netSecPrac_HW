import angr

def check_symbolic_bits(state,val):
    bits = 0
    for idx in range(state.arch.bits):
        if val[idx].symbolic:
            bits += 1
    return bits

def print_pc_overflow_msg(state,byte_s):
    print("\n[========find a pc overflow========]")
    print("over for ", hex(byte_s), "bytes")
    print("[PC]stdout:\n", state.posix.dumps(1))
    print("[PC]trigger overflow input:")
    print(state.posix.dumps(0))

def print_bp_overflow_msg(state,byte_s):
    print("\n[========find a bp overflow========]")
    print("over for ", hex(byte_s), "bytes")
    print("[PC]stdout:\n", state.posix.dumps(1))
    print("[PC]trigger overflow input:", state.posix.dumps(0))


def check_end(state):
    if state.addr==0:
        return
    insns=state.project.factory.block(state.addr).capstone.insns
    if len(insns)>=2:
        flag=0
        for ins in insns:
            if ins.insn.mnemonic=="leave":
                flag+=1
            if ins.insn.mnemonic=="ret":
                flag+=1
        if flag==2: # 1-3
            rsp=state.regs.rsp
            rbp=state.regs.rbp
            byte_s=state.arch.bytes
            stack_rbp=state.memory.load(rbp,endness=angr.archinfo.Endness.LE)
            stack_ret=state.memory.load(rbp+byte_s,endness=angr.archinfo.Endness.LE)
            pre_target=state.callstack.ret_addr
            pre_rbp=state.globals['rbp_list'][hex(pre_target)]

            if stack_ret.symbolic: # 1-4
                num=check_symbolic_bits(state,stack_ret)
                print_pc_overflow_msg(state,num//byte_s)
                state.memory.store(rbp,pre_rbp,endness=angr.archinfo.Endness.LE)
                state.memory.store(rbp+byte_s, state.solver.BVV(pre_target, 64),endness=angr.archinfo.Endness.LE)
                return

            if stack_rbp.symbolic: # 1-5
                num=check_symbolic_bits(state,stack_rbp)
                print_bp_overflow_msg(state,num//byte_s)
                state.memory.store(rbp,pre_rbp,endness=angr.archinfo.Endness.LE)

def check_head(state):
    insns=state.project.factory.block(state.addr).capstone.insns
    if len(insns)>=2:
        ins0=insns[0].insn
        ins1=insns[1].insn
        if len(ins0.operands)==1 and len(ins1.operands)==2:
            ins0_name=ins0.mnemonic
            ins0_op0=ins0.reg_name(ins0.operands[0].reg)
            ins1_name=ins1.mnemonic
            ins1_op0=ins1.reg_name(ins1.operands[0].reg)
            ins1_op1=ins1.reg_name(ins1.operands[1].reg)

            if ins0_name=="push" and ins0_op0=="rbp" and ins1_name=="mov" and ins1_op0=="rbp" and ins1_op1=="rsp": # 1-2
                pre_target=state.callstack.ret_addr
                state.globals['rbp_list'][hex(pre_target)]=state.regs.rbp


if __name__ == '__main__':  
    filename="stack1"
    p = angr.Project(filename,auto_load_libs=False)
    state=p.factory.entry_state()
    state.globals['rbp_list']={}
    simgr = p.factory.simulation_manager(state,save_unconstrained=True)

    while simgr.active:
        for act in simgr.active:
            check_head(act)
            check_end(act)
        simgr.step()

